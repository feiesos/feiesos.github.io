+++
date = '2026-01-22T11:33:28+08:00'
draft = false
mathjax = true
title = '消息队列重复消息问题'
+++
消息传递的过程中，如果出现传递失败的情况，发送方会执行重试，重试的过程中就有可能会产生重复的消息。

对于使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。
- 比如订单付款的消息，如果被重复消费会导致多次扣费

## 消息重复不可避免
消息队列本身无法保证消息不重复。[^1]

在MQTT协议（Message Queuing Telemetry Transport）中，给出了三种传递消息的服务质量标准：
1. QoS 0 (At most once)：至多一次。发送者只管把消息发出去，不要求接收者确认。不保证交付，消息不会重复。
2. QoS 1 (At least once)：至少一次。发送者发消息，接收者必须确认，如果确认等待超时，发送者会重发。能保证交付，消息可能重复。
3. QoS 2 (Exactly once)：恰好一次。“四步握手”机制[^2]保证消息到达且不重复。能保证交付，且消息不会重复。

绝大多数消息队列都提供QoS 1的服务质量，因此，就需要我们的消费端能够应对可能的消息重复。

## 应对可能的消息重复问题
### 幂等性消费操作
在数学上，幂等表示为 $f(f(x)) = f(x)$。

在计算机领域，幂等性是操作（或服务）的一种逻辑属性，一个具有幂等性的操作无论执行多少次，产生的业务结果（对系统状态的影响）都是一致的。

下面我们来举个生活中的例子，来说明什么是幂等操作：
> 你匆忙进入电梯，很着急地想去7楼，于是你狂按按钮“7”，按钮灯亮起，电梯将你送往7楼。

这就是一个典型的幂等性操作，无论你按一次还是多次（当然我们忽略有双击取消功能的电梯），电梯最终会把把你送到7楼一次。

如果我们的消费端业务代码具有幂等性，让多次消费等同于一次消费，那消息重复的问题不就迎刃而解了吗？没错，确实如此。

但是我们要怎么实现呢？

### 如何实现幂等性操作
1. 数据库唯一约束
在数据库中，将业务唯一性字段设置为唯一索引，当重复请求到来时，数据库会抛出异常，阻止请求重复执行。
2. 状态机幂等
在更新数据库时，带上当前状态作为过滤条件，比如第一次请求将状态从`pending`改为`processed`，之后重复请求时，有状态已变，更新不予执行。
3. 去重表/幂等表
如果你的业务逻辑复杂，可以尝试准备一张“去重表”并遵循以下步骤进行操作：
 - 开启事务
 - 向去重表中插入业务唯一ID
 - 执行复杂业务逻辑
 - 提交事务
当重复操作时，第二部的插入会失败，整个事务回滚。
4. 分布式锁
请求到来时，申请锁，并设置过期时间（防止死锁），成功拿到锁的执行，否则不执行。
5. Token机制
- 客户先请求服务器获取全局唯一token
- 提交业务时带上token
- 服务器判断token是否存在，存在则删除并执行，否则拒绝
6. 版本控制
利用版本号（乐观锁），操作前检查版本号，操作后更新版本号。
7. ...

在实际工程中，我们应根据场景灵活选择，如果业务本身就有状态流转，那状态机是成本最低、性能最好的方案；如果业务需要处理余额等敏感数据更新时，乐观锁则是“金融级”标准做法；业务逻辑执行前，使用redis分布式锁当掉重复请求，减轻数据库压力等等。


[^1]:消息队列本身很难保证消息不重复，但也不是完全不可能，这需要付出代价，因此严谨说法应该是“性能良好的消息队列本身无法保证消息不重复”。
[^2]:发送者发PUBLISH；接收者存下消息ID，回PUBREC确认；发送者确认对方收到，发PUBREL释放；接收者结束逻辑，回PUBCOMP完成。