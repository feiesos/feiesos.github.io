+++
date = '2026-01-14T11:17:02+08:00'
draft = false
title = 'Week04'
toc = true
tocBorder = true
+++
# 缓存
## Redis使用规范
### Key命名规范
1. 命名格式
采用 “**系统标识：业务域：模块：唯一标识 [: 属性]**” 的层级结构，用英文冒号`:`分隔，全小写字母，单词间用下划线`_`连接（禁止使用特殊字符如`[space]`、`@`、`#`等）
2. 各层级说明
| 层级 | 含义 | 示例 |
| :--- | :--- | :--- |
| 系统标识 | 唯一标识所属系统（与服务名/项目名一致，避免跨系统冲突） | user_center、order_service |
| 业务域 | 系统内的核心业务模块集合（如用户域、商品域）| user、goods、marketing |
| 模块 | 业务域下的具体功能模块（如信息、库存、优惠券） | info、stock、coupon |
| 唯一标识 | 业务主键（如用户ID、订单号，确保key唯一性） | 10086（用户ID）、2023112001（订单号） |
| 属性（可选） | 统一标识的细分属性（如锁、计数器、临时状态） | lock、count、temp |
3. 示例
- 用户中心系统的用户地址信息：`aaa_service:user_center:user:address:10086`
- 订单系统的订单支付锁：`aaa_service:order_service:order:pay:2023112001:lock`
- 商品系统的库存计数器：`aaa_service:goods_service:goods:stock:1001:count`
- 公共分布式锁（跨系统共享）：`aaa_service:common:distributed_lock:order_1001`
4. 命名原则
- **禁止模糊命名**：不允许使用data、value、key1等无业务含义的名称
- **控制长度**：总长度≤64字节（Redis对长key的哈希计算效率低，且占用更多内存）
- **避免缩写歧义**：仅使用公认缩写（如api、sku），禁止uc（代替user_center）等模糊缩写
- **唯一性保证**：同一业务场景下的key必须唯一，避免不同数据共用一个key导致覆盖

### 数据结构选型规范
根据业务场景选择最优数据结构，避免滥用String导致性能浪费或功能受限
| 数据结构 | 使用场景 | 不适用场景 | 核心操作与注意事项 |
| :--- | :--- | :--- | :--- |
| String | 简单K-V缓存（如token、单个数值） | 复杂对象、需频繁批量修改字段的场景 | 核心：`GET`/`SET`注意：大值（>10KB）需压缩（如 GZIP）；避免频繁`APPEND`导致内存碎片 |
| Hash | 存储对象（如用户信息、商品属性） | 字段数>1000 或需跨对象查询 | 核心：`HMGET` 按需获取注意： 禁止`HGETALL`全量查询；字段名建议简短化（如用`n`代替`name`） |
| List | 消息队列、最新列表（如最近评论） | 需随机访问、大量删除中间元素的场景 | 核心：`LPUSH`/`RPOP`注意：避免`LINDEX`（O(n)耗时）；长度控制在1000以内，过长需分片 |
| Set | 去重集合（如用户标签、共同好友） | 需要元素有序、需按分数排序的场景 | 核心：`SINTER`/`SUNION`注意：集合操作仅限小集合（<1000）；避免使用`SMEMBERS`全量返回 |
| Sorted Set | 排序场景（如排行榜、带权重的队列） | 无需排序、高频更新分数的简单集合 | 核心：`ZRANGEBYSCORE`注意：用分页查询禁止全量返回；分数范围不宜过大以防内存占用高 |
| Bitmap | 二进制状态记录（如签到、在线状态） | 非布尔型场景、ID极其不连续/稀疏的场景 | 核心：`BITCOUNT`/`BITOP`注意：避免单个Bitmap过大，建议按用户ID区间进行分片存储 |
| HyperLogLog | 基数统计（如UV计数、独立访客） | 需要精确计数、需要存储/提取原始数据的场景 | 核心：`PFADD`/`PFCOUNT`注意：接受0.81%误差；不支持删除单个元素，适合固定生命周期场景 |

**选型原则**：
- **有限紧凑存储**：如用户标签用Set而非多个String，对象属性用Hash而非JSON字符串
- **避免低效操作**：禁止key *（阻塞Redis），改用scan迭代；禁止List得lrem全量删除（O(n)耗时）
- **大key拆分**：单个key的value大小≤100KB，超过时拆分（如大Hash按ID区间拆分为多个小Hash）

### 过期策略
1. **必须设置过期时间的场景（强制约束）**
- **缓存数据**：如商品详情、用户会话、接口返回结果（避免Redis成为“内存黑洞”）
- **临时数据**：如验证码（5分钟）、分布式锁（30秒+续期）、限流计数（1小时）
- **周期性数据**：如每日排行榜、当日活跃用户（过期时间设为次日凌晨）
2. 允许不设置过期时间的场景（严格限制）
仅以下场景可豁免，且需满足 “数据量极小（总占用内存≤1MB）、长期不变、核心配置”：
- 系统基础配置（如业务开关、常量字典，如`common:config:business_switch`）
- 永久标识映射（如用户ID与唯一编码的映射，且总量≤1万条）
- 豁免场景需经技术负责人审批，并在key中注明permanent标识（如`common:permanent:config:pay_channels`）
3. **过期时间设置原则**
- **与业务时效匹配**：
    - 高频变更数据（如库存）：5-10分钟（结合主动更新，避免缓存与数据库不一致）
    - 低频变更数据（如地区字典）：1-7天（配合更新机制，如变更时主动删除缓存）
    - 会话数据：与用户会话超时时间一致（如 2 小时）
- **避免集中过期**：批量生成的key（如定时任务结果）需加随机偏移量（如 3600 + rand(0, 300) 秒），防止过期清理时的 CPU 峰值
- **原子化设置**：优先用`SET key value EX seconds`或`HSET key field value EX seconds`（Redis 6.2+支持Hash字段过期），避免SET后单独EXPIRE（中间故障可能导致key永久有效）
4. **过期策略监控**
- 定期巡检：通过redis-cli --bigkeys或监控工具（如Prometheus+Redis Exporter）排查无过期时间的key，非豁免场合必须整改
- 告警阈限：五过期时间的key数量占比>5%时触发告警，内存占比>1%时紧急处理

### 核心注意事项
1. **缓存一致性与更新**
- 优先采用 “更新数据库后删除缓存”（而非更新缓存），避免并发场景下的缓存脏数据
- 高并发更新场景需加锁（如分布式锁），防止缓存击穿（缓存失效时大量请求直达数据库）
- 缓存穿透防护：对不存在的key缓存空值（设置短期过期，如1分钟），避免恶意请求攻击数据库
2. **内存与性能控制**
- 内存使用率阈值：生产环境 Redis 内存使用率≤80%（避免触发内存淘汰策略导致正常数据被删）
- 禁止存储大value：单个value＞1MB 需拆分（如大JSON拆分为多个小key），避免网络传输耗时过长
- 控制key总量：单实例key数量建议≤1000万（过多会导致Redis启动加载慢、内存碎片率高）
3. **安全与合规**
- 禁止缓存敏感信息：如密码、身份证号、银行卡号（如需缓存，必须加密且过期时间≤1小时）
- 权限控制：开发/测试环境Redis禁止直连生产实例；生产环境仅允许应用服务通过指定账号访问，禁止人工redis-cli操作（特殊情况需审批）
4. **环境隔离**
- 不同环境（开发/测试/生产）必须使用独立Redis实例或数据库（select dbindex），禁止共用实例（避免测试数据污染生产）
- 多团队共用Redis集群时，通过 “系统标识” 严格隔离，禁止跨团队操作非自有 key
5. **命令使用禁忌**
- 禁止使用阻塞命令：keys *、flushall、flushdb（生产环境禁用，测试环境需谨慎）
- 限制高危命令：hgetall、smembers、zrange等全量查询命令仅允许在小集合上使用（元素≤100）
- 禁用eval复杂脚本：避免长时间阻塞Redis主线程（脚本执行时间≤100ms）