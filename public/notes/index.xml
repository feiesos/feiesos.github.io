<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes on Feiesos&#39; blog</title>
    <link>https://feiesos.github.io/notes/</link>
    <description>Recent content in Notes on Feiesos&#39; blog</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 26 Dec 2025 21:23:39 +0800</lastBuildDate>
    <atom:link href="https://feiesos.github.io/notes/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算机操作系统</title>
      <link>https://feiesos.github.io/notes/second/</link>
      <pubDate>Fri, 26 Dec 2025 21:23:39 +0800</pubDate>
      <guid>https://feiesos.github.io/notes/second/</guid>
      <description>&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;h1 id=&#34;进程的描述与控制&#34;&gt;进程的描述与控制&lt;/h1&gt;&#xA;&lt;p&gt;&amp;hellip;&lt;/p&gt;&#xA;&lt;h2 id=&#34;进程的描述&#34;&gt;进程的描述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;进程的定义与特征&#34;&gt;进程的定义与特征&lt;/h3&gt;&#xA;&lt;p&gt;传统OS中进程的定义：进程是程序的&lt;em&gt;执行过程&lt;/em&gt;，是系统进行&lt;em&gt;资源分配&lt;/em&gt;和&lt;em&gt;调度&lt;/em&gt;的一个&lt;strong&gt;独立单位&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;进程的四个特性：&#xA;- &lt;strong&gt;动态性&lt;/strong&gt;，最基本特性。进程的本质是程序的动态执行。&#xA;- &lt;strong&gt;并发性&lt;/strong&gt;，重要特性。进程的目的就是为了使进程和其他进程并发执行。&#xA;- &lt;strong&gt;独立性&lt;/strong&gt;。晋城市独立运行、独立获得资源、独立接受调度的基本单位。&#xA;- &lt;strong&gt;异步性&lt;/strong&gt;。进程是并发结果可再现的基础，为并发结果的再现提供了可能。&lt;/p&gt;&#xA;&lt;h3 id=&#34;进程的基本状态与转换&#34;&gt;进程的基本状态与转换&lt;/h3&gt;&#xA;&lt;p&gt;进程的五种&lt;strong&gt;基本状态&lt;/strong&gt;：&#xA;1. 就绪态，进程已分配好除CPU外的所有资源。&#xA;2. 执行态，进程正在执行。&#xA;3. 阻塞态，进程由于某些事件的发生被阻塞，这时会发生进程调度。&#xA;4. 创建状态。引入创建状态是为了保证进程的调度必须在创建工作完成后进行。&#xA;5. 终止状态。&lt;/p&gt;&#xA;&lt;p&gt;进程状态间的转换图：&#xA;&lt;img src=&#34;image.png&#34; alt=&#34;进程状态间的转换图&#34;&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;挂起操作和进程状态的转换&#34;&gt;挂起操作和进程状态的转换&lt;/h3&gt;&#xA;&lt;p&gt;挂起是操作系统为了满足系统和用户观察与分析进程的需要而引入的，是三个基本状态之外的、面向进程的重要操作。&lt;/p&gt;&#xA;&lt;p&gt;挂起操作主要是为了满足以下需要：&#xA;1. 终端用户的需要：终端用户希望能够暂停运行中的程序，以便研究执行情况或对其进行修改等。&#xA;2. 父进程的需要：父进程有时需要挂起自己的某个子进程，以便考察和修改该紫禁城，或者协调各个进程间的活动。&#xA;3. 负荷调节的需要：当实时系统中工作负荷较重，系统为保证自身能正常运行，可能把一些不重要的进程挂起。&#xA;4. OS的需要：OS有时希望挂起某些进程，以便检查在进程运行过程中资源的使用情况或者进行记账（CPU时间、实际使用时间、作业或进程数量等）。&lt;/p&gt;&#xA;&lt;p&gt;引入挂起操作后进程3个基本状态间的转换：&#xA;挂起原语Suspend和激活源于Active（成对使用）的共同作用下，进程可能发生这些状态转换。&#xA;1. 活动就绪 -&amp;gt; 静止就绪&#xA;2. 活动阻塞 -&amp;gt; 静止阻塞&#xA;3. 静止就绪 -&amp;gt; 活动就绪&#xA;4. 静止阻塞 -&amp;gt; 活动阻塞&#xA;引入创建和终止状态后，还需补充&#xA;1. NULL -&amp;gt; 创建&#xA;2. 创建 -&amp;gt; 活动就绪&#xA;3. 创建 -&amp;gt; 静止就绪&#xA;4. 执行 -&amp;gt; 终止&lt;/p&gt;</description>
    </item>
    <item>
      <title>Spring Boot笔记</title>
      <link>https://feiesos.github.io/notes/first/</link>
      <pubDate>Tue, 23 Dec 2025 19:20:37 +0800</pubDate>
      <guid>https://feiesos.github.io/notes/first/</guid>
      <description>&lt;h1 id=&#34;springboot3快速入门&#34;&gt;SpringBoot3快速入门&lt;/h1&gt;&#xA;&lt;h2 id=&#34;自动配置机制&#34;&gt;自动配置机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;springboot默认扫包规则&#34;&gt;SpringBoot默认扫包规则&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;@SpringBootApplication&lt;/code&gt;标注的类就是主程序类。SpringBoot只会扫描主程序所在的包及其子包，相当于自动的component-scan（ssm）。&#xA;当然也可以自定义配置扫包：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;通过&lt;code&gt;@SpringBootApplication(scanBasePackages=&amp;quot;you.package.path&amp;quot;)&lt;/code&gt;注解的scanBasePackages参数配置&lt;/p&gt;&#xA;&lt;p&gt;@SpringBootApplication相当于同时使用以下三个注解：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SpringBootConfiguration&lt;/li&gt;&#xA;&lt;li&gt;EnableAutoConfiguration&lt;/li&gt;&#xA;&lt;li&gt;ComponentScan&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;当然也可以通过&lt;code&gt;ComponentScan(&amp;quot;your.package.path&amp;quot;)&lt;/code&gt;注解来配置&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;配置文件默认值&#34;&gt;配置文件默认值&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;配置文件的所有配置项是和某个类的对象值进行一一绑定的。这些类我们从称为&lt;strong&gt;配置属性类&lt;/strong&gt;。&lt;/p&gt;&#xA;&lt;p&gt;比如，server.port这个配置项，对应ServerProperties类中的port成员变量。ServerProperties类绑定了所有Tomcat服务器有关的配置。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h3 id=&#34;按需加载自动配置&#34;&gt;按需加载自动配置&lt;/h3&gt;&#xA;&lt;p&gt;导入场景spring-boot-starter-xxx，场景启动器（starter）除了会导入相关功能以外，还会导入一个&lt;code&gt;spring-boot-starter&lt;/code&gt;，这是核心场景启动器，是所有starter的starter。&lt;/p&gt;&#xA;&lt;p&gt;spring-boot-starter导入了一个包spring-boot-autoconfigure。包里面是各种场景的&lt;code&gt;AutoConfiguration&lt;/code&gt;自动配置类。&lt;/p&gt;&#xA;&lt;p&gt;虽然全场景的自动配置都在spring-boot-autoconfigure这个包，但是不都是全部开启的，而是按需开启，也就是导入了哪些就开启哪些。&lt;/p&gt;&#xA;&lt;p&gt;总结：导入场景启动器，触发spring-boot-autoconfigure包的自动配置生效，容器就会具有相关场景。&lt;/p&gt;&#xA;&lt;h2 id=&#34;核心技能&#34;&gt;核心技能&lt;/h2&gt;&#xA;&lt;h3 id=&#34;常用注解&#34;&gt;常用注解&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;组件注册&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;@Configuration: 告诉Spring容器这是一个配置类（配置类本身也是容器中的组件）&lt;/li&gt;&#xA;&lt;li&gt;@SpringBootConfiguration: 告诉容器这是一个SpringBoot配置类，跟Configuration没区别，仅主要用于主应用类&lt;/li&gt;&#xA;&lt;li&gt;@Bean: 注册一个Bean，组件在容器中的名字默认是方法名，不过可以通过Bean(&amp;ldquo;alias&amp;rdquo;)设置组件名&lt;/li&gt;&#xA;&lt;li&gt;@Controller&lt;/li&gt;&#xA;&lt;li&gt;@Service&lt;/li&gt;&#xA;&lt;li&gt;@Repository&lt;/li&gt;&#xA;&lt;li&gt;@Component&lt;/li&gt;&#xA;&lt;li&gt;@Import&lt;/li&gt;&#xA;&lt;li&gt;@ComponentScan&lt;/li&gt;&#xA;&lt;li&gt;&amp;hellip;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;组件默认是单实例的（每次获取都会获得同一个实例），可以通过@Scoop(&amp;ldquo;prototype&amp;rdquo;)设置组件为多实例（每次获取都会获得一个新的实例）。&lt;/p&gt;&#xA;&lt;p&gt;组件注册的步骤：&#xA;1. 配置类注册@Configuration注解&#xA;2. 在配置类中，自定义方法给容器中注册组件（配合@Bean）&#xA;3. 或者使用@Import导入第三方组件&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;条件注解&#xA;如果注解置顶的条件成立，则触发指定行为。&lt;/p&gt;&#xA;&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;类似@ConditionalOnXxx的注解就是条件注解。&lt;/p&gt;&#xA;&lt;p&gt;例如@ConditionalOnClass，当类路径中存在这个类，则触发指定行为；相对的@ConditionalOnMissingClass反之。&lt;/p&gt;&#xA;&lt;p&gt;再比如@ConditionalOnBean，当容器中存在这个Bean（组件），则触发指定行为；相对的还有@ConditionalOnMissingBean。&lt;/p&gt;&#xA;&lt;ol start=&#34;3&#34;&gt;&#xA;&lt;li&gt;属性绑定&#xA;@ConfigurationProperties和@EnableConfigurationProperties&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;将容器汇总任意组件（Bean）的属性值和配置文件的配置项的值进行绑定&lt;/p&gt;&#xA;&lt;p&gt;使用@ConfigurationProperties进项绑定：&#xA;1. 向容器中注册组件（使用@Compoent、@Bean等都可以）&#xA;2. 使用@ConfigurationProperties(prefix=&amp;ldquo;theitemtobind&amp;rdquo;)注解（在需绑定的类或方法上）声明与配置文件中的对应的项（prefix参数的值）的绑定关系&lt;/p&gt;&#xA;&lt;p&gt;也可以使用@EnableConfigurationProperties进行绑定：&#xA;- 只需在配置类上注解就能&lt;code&gt;向容器中注册组件&lt;/code&gt;并&lt;code&gt;绑定属性&lt;/code&gt;，这个注解其实就是整合了@Import和@ConfigurationProperties&lt;/p&gt;&#xA;&lt;p&gt;由于SpringBoot默认只扫描主程序所在的包，@EnableConfigurationProperties用于第三方组件的绑定，@ConfigurationProperties用于自己写的组件的绑定&lt;/p&gt;&#xA;&lt;h2 id=&#34;总结&#34;&gt;总结&lt;/h2&gt;&#xA;&lt;p&gt;导入starter &amp;ndash;&amp;gt; 生效一系列的xxxAutoConfiguration自动配置类 &amp;ndash;&amp;gt; 在容器中注册很多组件 &amp;ndash;&amp;gt; 组件参数绑定在xxxProperties属性类中 &amp;ndash;&amp;gt; 关联配置文件&#xA;|                                                         |&#xA;使用Autowired自动装配                                           配置属性&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
