<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="消息传递的过程中，如果出现传递失败的情况，发送方会执行重试，重试的过程中就有可能会产生重复的消息。
对于使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。

比如订单付款的消息，如果被重复消费会导致多次扣费

消息重复不可避免
消息队列本身无法保证消息不重复。1
在MQTT协议（Message Queuing Telemetry Transport）中，给出了三种传递消息的服务质量标准：

QoS 0 (At most once)：至多一次。发送者只管把消息发出去，不要求接收者确认。不保证交付，消息不会重复。
QoS 1 (At least once)：至少一次。发送者发消息，接收者必须确认，如果确认等待超时，发送者会重发。能保证交付，消息可能重复。
QoS 2 (Exactly once)：恰好一次。“四步握手”机制2保证消息到达且不重复。能保证交付，且消息不会重复。

绝大多数消息队列都提供QoS 1的服务质量，因此，就需要我们的消费端能够应对可能的消息重复。
应对可能的消息重复问题
幂等性消费操作
在数学上，幂等表示为 $f(f(x)) = f(x)$。
在计算机领域，幂等性是操作（或服务）的一种逻辑属性，一个具有幂等性的操作无论执行多少次，产生的业务结果（对系统状态的影响）都是一致的。
下面我们来举个生活中的例子，来说明什么是幂等操作：

你匆忙进入电梯，很着急地想去7楼，于是你狂按按钮“7”，按钮灯亮起，电梯将你送往7楼。

这就是一个典型的幂等性操作，无论你按一次还是多次（当然我们忽略有双击取消功能的电梯），电梯最终会把你送到7楼一次。
如果我们的消费端业务代码具有幂等性，让多次消费等同于一次消费，那消息重复的问题不就迎刃而解了吗？没错，确实如此。
但是我们要怎么实现呢？
如何实现幂等性操作

数据库唯一约束
在数据库中，将业务唯一性字段设置为唯一索引，当重复请求到来时，数据库会抛出异常，阻止请求重复执行。
状态机幂等
在更新数据库时，带上当前状态作为过滤条件，比如第一次请求将状态从pending改为processed，之后重复请求时，有状态已变，更新不予执行。
去重表/幂等表
如果你的业务逻辑复杂，可以尝试准备一张“去重表”并遵循以下步骤进行操作：


开启事务
向去重表中插入业务唯一ID
执行复杂业务逻辑
提交事务
当重复操作时，第二部的插入会失败，整个事务回滚。


分布式锁
请求到来时，申请锁，并设置过期时间（防止死锁），成功拿到锁的执行，否则不执行。
Token机制


客户先请求服务器获取全局唯一token
提交业务时带上token
服务器判断token是否存在，存在则删除并执行，否则拒绝


版本控制
利用版本号（乐观锁），操作前检查版本号，操作后更新版本号。
&hellip;

在实际工程中，我们应根据场景灵活选择，如果业务本身就有状态流转，那状态机是成本最低、性能最好的方案；如果业务需要处理余额等敏感数据更新时，乐观锁则是“金融级”标准做法；业务逻辑执行前，使用redis分布式锁当掉重复请求，减轻数据库压力等等。




消息队列本身很难保证消息不重复，但也不是完全不可能，这需要付出代价，因此严谨说法应该是“性能良好的消息队列本身无法保证消息不重复”。&#160;&#x21a9;&#xfe0e;


发送者发PUBLISH；接收者存下消息ID，回PUBREC确认；发送者确认对方收到，发PUBREL释放；接收者结束逻辑，回PUBCOMP完成。&#160;&#x21a9;&#xfe0e;


">  

  <title>
    
      消息队列重复消息问题
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.900100e9dbee2d56c58fac8bb717037cae7e26a9c36c29d2ff587bdd65f0cbbe510b41d81a3bb234919cdfdc7550d786b2fab70c8fc507772d732fe097106d12.css" integrity="sha512-kAEA6dvuLVbFj6yLtxcDfK5&#43;JqnDbCnS/1h73WXwy75RC0HYGjuyNJGc39x1UNeGsvq3DI/FB3ctcy/glxBtEg==" />
   <script>
  MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      displayMath: [['$$','$$'], ['\\[', '\\]']],
      processEscapes: true,
      processEnvironments: true
    },
    options: {
      skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
    }
  };

  window.addEventListener('load', (event) => {
      document.querySelectorAll("mjx-container").forEach(function(x){
        x.parentElement.classList += 'has-jax'})
    });

</script>
<script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
 
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2026-01-22 11:33:28 &#43;0800 CST">
                            2026-01-22
                        </time>
                    </p>
                </div>

<article>
    <h1>消息队列重复消息问题</h1>

    

    <p>消息传递的过程中，如果出现传递失败的情况，发送方会执行重试，重试的过程中就有可能会产生重复的消息。</p>
<p>对于使用消息队列的业务系统来说，如果没有对重复消息进行处理，就有可能会导致系统的数据出现错误。</p>
<ul>
<li>比如订单付款的消息，如果被重复消费会导致多次扣费</li>
</ul>
<h2 id="消息重复不可避免">消息重复不可避免</h2>
<p>消息队列本身无法保证消息不重复。<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>在MQTT协议（Message Queuing Telemetry Transport）中，给出了三种传递消息的服务质量标准：</p>
<ol>
<li>QoS 0 (At most once)：至多一次。发送者只管把消息发出去，不要求接收者确认。不保证交付，消息不会重复。</li>
<li>QoS 1 (At least once)：至少一次。发送者发消息，接收者必须确认，如果确认等待超时，发送者会重发。能保证交付，消息可能重复。</li>
<li>QoS 2 (Exactly once)：恰好一次。“四步握手”机制<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup>保证消息到达且不重复。能保证交付，且消息不会重复。</li>
</ol>
<p>绝大多数消息队列都提供QoS 1的服务质量，因此，就需要我们的消费端能够应对可能的消息重复。</p>
<h2 id="应对可能的消息重复问题">应对可能的消息重复问题</h2>
<h3 id="幂等性消费操作">幂等性消费操作</h3>
<p>在数学上，幂等表示为 $f(f(x)) = f(x)$。</p>
<p>在计算机领域，幂等性是操作（或服务）的一种逻辑属性，一个具有幂等性的操作无论执行多少次，产生的业务结果（对系统状态的影响）都是一致的。</p>
<p>下面我们来举个生活中的例子，来说明什么是幂等操作：</p>
<blockquote>
<p>你匆忙进入电梯，很着急地想去7楼，于是你狂按按钮“7”，按钮灯亮起，电梯将你送往7楼。</p>
</blockquote>
<p>这就是一个典型的幂等性操作，无论你按一次还是多次（当然我们忽略有双击取消功能的电梯），电梯最终会把你送到7楼一次。</p>
<p>如果我们的消费端业务代码具有幂等性，让多次消费等同于一次消费，那消息重复的问题不就迎刃而解了吗？没错，确实如此。</p>
<p>但是我们要怎么实现呢？</p>
<h3 id="如何实现幂等性操作">如何实现幂等性操作</h3>
<ol>
<li>数据库唯一约束
在数据库中，将业务唯一性字段设置为唯一索引，当重复请求到来时，数据库会抛出异常，阻止请求重复执行。</li>
<li>状态机幂等
在更新数据库时，带上当前状态作为过滤条件，比如第一次请求将状态从<code>pending</code>改为<code>processed</code>，之后重复请求时，有状态已变，更新不予执行。</li>
<li>去重表/幂等表
如果你的业务逻辑复杂，可以尝试准备一张“去重表”并遵循以下步骤进行操作：</li>
</ol>
<ul>
<li>开启事务</li>
<li>向去重表中插入业务唯一ID</li>
<li>执行复杂业务逻辑</li>
<li>提交事务
当重复操作时，第二部的插入会失败，整个事务回滚。</li>
</ul>
<ol start="4">
<li>分布式锁
请求到来时，申请锁，并设置过期时间（防止死锁），成功拿到锁的执行，否则不执行。</li>
<li>Token机制</li>
</ol>
<ul>
<li>客户先请求服务器获取全局唯一token</li>
<li>提交业务时带上token</li>
<li>服务器判断token是否存在，存在则删除并执行，否则拒绝</li>
</ul>
<ol start="6">
<li>版本控制
利用版本号（乐观锁），操作前检查版本号，操作后更新版本号。</li>
<li>&hellip;</li>
</ol>
<p>在实际工程中，我们应根据场景灵活选择，如果业务本身就有状态流转，那状态机是成本最低、性能最好的方案；如果业务需要处理余额等敏感数据更新时，乐观锁则是“金融级”标准做法；业务逻辑执行前，使用redis分布式锁当掉重复请求，减轻数据库压力等等。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>消息队列本身很难保证消息不重复，但也不是完全不可能，这需要付出代价，因此严谨说法应该是“性能良好的消息队列本身无法保证消息不重复”。&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>发送者发PUBLISH；接收者存下消息ID，回PUBREC确认；发送者确认对方收到，发PUBREL释放；接收者结束逻辑，回PUBCOMP完成。&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>

    
    
    
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
<script>
  const gitalk = new Gitalk({
    clientID: 'Ov23liutI7L71Kv4y4Qq',
    clientSecret: 'afc44c8b83a211534ea2b72eff3fceaa9eb3c7e2',
    proxy: 'https:\/\/my-gitalk-proxy.f10000914.workers.dev',
    repo: 'feiesos.github.io',
    owner: 'feiesos',
    admin: ['feiesos'],
    id: location.pathname, 
    distractionFreeMode: false 
  });
  (function() {
    
    
    
    
    
    gitalk.render('gitalk-container');
  })();
</script>

</article>

            </div>
        </main>
    </body></html>
