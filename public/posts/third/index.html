<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="简单介绍Kafka
Kafka是分布式系统，通常以集群的方式部署。
也就是说会同时存在多个Kafka实例（Broker），这些实例一般部署在不同服务器上。
稍后将讲解。
Kafka最初就是为了解决大数据的实时日志流而生的，它被用来处理每天千亿规模的日志量级。
相比RocketMQ和RabbitMQ等消息队列，Kafka的核心优势就是吞吐量大，能达到17.3w/s，相比之下RocketMQ只有11.6w/s，RabbitMQ只有5.95w/s，因此Kafka十分适合大规模、高吞吐的应用场景。
RabbitMQ和RocketMQ虽然性能不如Kafka，但是功能完善还有其他方面的优点，比如RocketMQ各方面最均衡、RabbitMQ运维成本低等。
下面我们绘制一个表格简单对比这三个数据库：
Kafka的基本概念

topic，主题，是消息归类的基本单元
partitions，消息分区，通过偏移量offset来置顶消息的位置，是实现消息的分布式管理的核心机制
replicas，分区副本，每个分区可以有多个副本，一个leader（读写）多个follower（拷贝）
broker，集群，Kafka由一个或多个broker组成集群，每一个broker就是一个Kafka实例
ZooKeeper，协调多个broker，存储元数据

主题和分区（Topic&amp;Partitions）
在Kafka中要实现消息的发送与订阅，必须首先创建Topic。
因为Topic是Kafka进行消息归类的基本单元。Topic接收生产者发布的消息，并将消息转发给消费者。
比如：
 -----------------                -------------------                 -----------------
| Producer(生产者)| ==发送消息==&gt; |      [Topic]     | &lt;==订阅消息== |Consumer(消费者) |
 -----------------                |     Kafka实例    |                -----------------
                                  -------------------
">  

  <title>
    
      Kafka快速入门
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.900100e9dbee2d56c58fac8bb717037cae7e26a9c36c29d2ff587bdd65f0cbbe510b41d81a3bb234919cdfdc7550d786b2fab70c8fc507772d732fe097106d12.css" integrity="sha512-kAEA6dvuLVbFj6yLtxcDfK5&#43;JqnDbCnS/1h73WXwy75RC0HYGjuyNJGc39x1UNeGsvq3DI/FB3ctcy/glxBtEg==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
                <div class="post-meta">
                    <a href="/">..</a>

                    <p>
                        <time datetime="2025-12-21 13:21:24 &#43;0800 CST">
                            2025-12-21
                        </time>
                    </p>
                </div>

<article>
    <h1>Kafka快速入门</h1>

    
        <aside  class="toc" >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#简单介绍kafka">简单介绍Kafka</a></li>
    <li><a href="#kafka的基本概念">Kafka的基本概念</a>
      <ul>
        <li><a href="#主题和分区topicpartitions">主题和分区（Topic&amp;Partitions）</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    

    <h2 id="简单介绍kafka">简单介绍Kafka</h2>
<p>Kafka是分布式系统，通常以集群的方式部署。</p>
<p>也就是说会同时存在多个Kafka实例（Broker），这些实例一般部署在不同服务器上。</p>
<p>稍后将讲解。</p>
<p>Kafka最初就是为了解决大数据的实时日志流而生的，它被用来处理每天千亿规模的日志量级。</p>
<p>相比RocketMQ和RabbitMQ等消息队列，Kafka的核心优势就是吞吐量大，能达到17.3w/s，相比之下RocketMQ只有11.6w/s，RabbitMQ只有5.95w/s，因此Kafka十分适合大规模、高吞吐的应用场景。</p>
<p>RabbitMQ和RocketMQ虽然性能不如Kafka，但是功能完善还有其他方面的优点，比如RocketMQ各方面最均衡、RabbitMQ运维成本低等。</p>
<p>下面我们绘制一个表格简单对比这三个数据库：</p>
<h2 id="kafka的基本概念">Kafka的基本概念</h2>
<ol>
<li>topic，主题，是消息归类的基本单元</li>
<li>partitions，消息分区，通过偏移量offset来置顶消息的位置，是实现消息的分布式管理的核心机制</li>
<li>replicas，分区副本，每个分区可以有多个副本，一个leader（读写）多个follower（拷贝）</li>
<li>broker，集群，Kafka由一个或多个broker组成集群，每一个broker就是一个Kafka实例</li>
<li>ZooKeeper，协调多个broker，存储元数据</li>
</ol>
<h3 id="主题和分区topicpartitions">主题和分区（Topic&amp;Partitions）</h3>
<p>在Kafka中要实现消息的发送与订阅，必须首先创建Topic。<br>
因为Topic是Kafka进行消息归类的基本单元。Topic接收生产者发布的消息，并将消息转发给消费者。<br>
比如：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span> -----------------                -------------------                 -----------------
</span></span><span style="display:flex;"><span>| Producer(生产者)| ==发送消息==&gt; |      [Topic]     | &lt;==订阅消息== |Consumer(消费者) |
</span></span><span style="display:flex;"><span> -----------------                |     Kafka实例    |                -----------------
</span></span><span style="display:flex;"><span>                                  -------------------
</span></span></code></pre></div>
</article>

            </div>
        </main>
    </body></html>
