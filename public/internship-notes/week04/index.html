<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
   <meta name="description" content="缓存
Redis使用规范
Key命名规范

命名格式
采用 “系统标识：业务域：模块：唯一标识 [: 属性]” 的层级结构，用英文冒号:分隔，全小写字母，单词间用下划线_连接（禁止使用特殊字符如[space]、@、#等）
各层级说明

  
      
          层级
          含义
          示例
      
  
  
      
          系统标识
          唯一标识所属系统（与服务名/项目名一致，避免跨系统冲突）
          user_center、order_service
      
      
          业务域
          系统内的核心业务模块集合（如用户域、商品域）
          user、goods、marketing
      
      
          模块
          业务域下的具体功能模块（如信息、库存、优惠券）
          info、stock、coupon
      
      
          唯一标识
          业务主键（如用户ID、订单号，确保key唯一性）
          10086（用户ID）、2023112001（订单号）
      
      
          属性（可选）
          统一标识的细分属性（如锁、计数器、临时状态）
          lock、count、temp
      
  


示例


用户中心系统的用户地址信息：aaa_service:user_center:user:address:10086
订单系统的订单支付锁：aaa_service:order_service:order:pay:2023112001:lock
商品系统的库存计数器：aaa_service:goods_service:goods:stock:1001:count
公共分布式锁（跨系统共享）：aaa_service:common:distributed_lock:order_1001


命名原则


禁止模糊命名：不允许使用data、value、key1等无业务含义的名称
控制长度：总长度≤64字节（Redis对长key的哈希计算效率低，且占用更多内存）
避免缩写歧义：仅使用公认缩写（如api、sku），禁止uc（代替user_center）等模糊缩写
唯一性保证：同一业务场景下的key必须唯一，避免不同数据共用一个key导致覆盖

数据结构选型规范
根据业务场景选择最优数据结构，避免滥用String导致性能浪费或功能受限

  
      
          数据结构
          使用场景
          不适用场景
          核心操作与注意事项
      
  
  
      
          String
          简单K-V缓存（如token、单个数值）
          复杂对象、需频繁批量修改字段的场景
          核心：GET/SET注意：大值（&gt;10KB）需压缩（如 GZIP）；避免频繁APPEND导致内存碎片
      
      
          Hash
          存储对象（如用户信息、商品属性）
          字段数&gt;1000 或需跨对象查询
          核心：HMGET 按需获取注意： 禁止HGETALL全量查询；字段名建议简短化（如用n代替name）
      
      
          List
          消息队列、最新列表（如最近评论）
          需随机访问、大量删除中间元素的场景
          核心：LPUSH/RPOP注意：避免LINDEX（O(n)耗时）；长度控制在1000以内，过长需分片
      
      
          Set
          去重集合（如用户标签、共同好友）
          需要元素有序、需按分数排序的场景
          核心：SINTER/SUNION注意：集合操作仅限小集合（&lt;1000）；避免使用SMEMBERS全量返回
      
      
          Sorted Set
          排序场景（如排行榜、带权重的队列）
          无需排序、高频更新分数的简单集合
          核心：ZRANGEBYSCORE注意：用分页查询禁止全量返回；分数范围不宜过大以防内存占用高
      
      
          Bitmap
          二进制状态记录（如签到、在线状态）
          非布尔型场景、ID极其不连续/稀疏的场景
          核心：BITCOUNT/BITOP注意：避免单个Bitmap过大，建议按用户ID区间进行分片存储
      
      
          HyperLogLog
          基数统计（如UV计数、独立访客）
          需要精确计数、需要存储/提取原始数据的场景
          核心：PFADD/PFCOUNT注意：接受0.81%误差；不支持删除单个元素，适合固定生命周期场景
      
  

选型原则：">  

  <title>
    
      Week04
    
  </title>


  <link rel="shortcut icon" type="image/x-icon" href="/" />
  
  
  
  <link rel="stylesheet" href="/css/main.900100e9dbee2d56c58fac8bb717037cae7e26a9c36c29d2ff587bdd65f0cbbe510b41d81a3bb234919cdfdc7550d786b2fab70c8fc507772d732fe097106d12.css" integrity="sha512-kAEA6dvuLVbFj6yLtxcDfK5&#43;JqnDbCnS/1h73WXwy75RC0HYGjuyNJGc39x1UNeGsvq3DI/FB3ctcy/glxBtEg==" />
  
</head>
<body a="auto">
        <main class="page-content" aria-label="Content">
            <div class="w">
<a href="/">..</a>


<article>
    <p class="post-meta">
        <time datetime="2026-01-14 11:17:02 &#43;0800 CST">
            2026-01-14
        </time>
    </p>

    <h1>Week04</h1>

    
        <aside  class="toc" >
            <nav id="TableOfContents">
  <ul>
    <li><a href="#redis使用规范">Redis使用规范</a>
      <ul>
        <li><a href="#key命名规范">Key命名规范</a></li>
        <li><a href="#数据结构选型规范">数据结构选型规范</a></li>
        <li><a href="#过期策略">过期策略</a></li>
        <li><a href="#核心注意事项">核心注意事项</a></li>
      </ul>
    </li>
  </ul>
</nav>
        </aside>
    

    <h1 id="缓存">缓存</h1>
<h2 id="redis使用规范">Redis使用规范</h2>
<h3 id="key命名规范">Key命名规范</h3>
<ol>
<li>命名格式
采用 “<strong>系统标识：业务域：模块：唯一标识 [: 属性]</strong>” 的层级结构，用英文冒号<code>:</code>分隔，全小写字母，单词间用下划线<code>_</code>连接（禁止使用特殊字符如<code>[space]</code>、<code>@</code>、<code>#</code>等）</li>
<li>各层级说明
<table>
  <thead>
      <tr>
          <th style="text-align: left">层级</th>
          <th style="text-align: left">含义</th>
          <th style="text-align: left">示例</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">系统标识</td>
          <td style="text-align: left">唯一标识所属系统（与服务名/项目名一致，避免跨系统冲突）</td>
          <td style="text-align: left">user_center、order_service</td>
      </tr>
      <tr>
          <td style="text-align: left">业务域</td>
          <td style="text-align: left">系统内的核心业务模块集合（如用户域、商品域）</td>
          <td style="text-align: left">user、goods、marketing</td>
      </tr>
      <tr>
          <td style="text-align: left">模块</td>
          <td style="text-align: left">业务域下的具体功能模块（如信息、库存、优惠券）</td>
          <td style="text-align: left">info、stock、coupon</td>
      </tr>
      <tr>
          <td style="text-align: left">唯一标识</td>
          <td style="text-align: left">业务主键（如用户ID、订单号，确保key唯一性）</td>
          <td style="text-align: left">10086（用户ID）、2023112001（订单号）</td>
      </tr>
      <tr>
          <td style="text-align: left">属性（可选）</td>
          <td style="text-align: left">统一标识的细分属性（如锁、计数器、临时状态）</td>
          <td style="text-align: left">lock、count、temp</td>
      </tr>
  </tbody>
</table>
</li>
<li>示例</li>
</ol>
<ul>
<li>用户中心系统的用户地址信息：<code>aaa_service:user_center:user:address:10086</code></li>
<li>订单系统的订单支付锁：<code>aaa_service:order_service:order:pay:2023112001:lock</code></li>
<li>商品系统的库存计数器：<code>aaa_service:goods_service:goods:stock:1001:count</code></li>
<li>公共分布式锁（跨系统共享）：<code>aaa_service:common:distributed_lock:order_1001</code></li>
</ul>
<ol start="4">
<li>命名原则</li>
</ol>
<ul>
<li><strong>禁止模糊命名</strong>：不允许使用data、value、key1等无业务含义的名称</li>
<li><strong>控制长度</strong>：总长度≤64字节（Redis对长key的哈希计算效率低，且占用更多内存）</li>
<li><strong>避免缩写歧义</strong>：仅使用公认缩写（如api、sku），禁止uc（代替user_center）等模糊缩写</li>
<li><strong>唯一性保证</strong>：同一业务场景下的key必须唯一，避免不同数据共用一个key导致覆盖</li>
</ul>
<h3 id="数据结构选型规范">数据结构选型规范</h3>
<p>根据业务场景选择最优数据结构，避免滥用String导致性能浪费或功能受限</p>
<table>
  <thead>
      <tr>
          <th style="text-align: left">数据结构</th>
          <th style="text-align: left">使用场景</th>
          <th style="text-align: left">不适用场景</th>
          <th style="text-align: left">核心操作与注意事项</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: left">String</td>
          <td style="text-align: left">简单K-V缓存（如token、单个数值）</td>
          <td style="text-align: left">复杂对象、需频繁批量修改字段的场景</td>
          <td style="text-align: left">核心：<code>GET</code>/<code>SET</code>注意：大值（&gt;10KB）需压缩（如 GZIP）；避免频繁<code>APPEND</code>导致内存碎片</td>
      </tr>
      <tr>
          <td style="text-align: left">Hash</td>
          <td style="text-align: left">存储对象（如用户信息、商品属性）</td>
          <td style="text-align: left">字段数&gt;1000 或需跨对象查询</td>
          <td style="text-align: left">核心：<code>HMGET</code> 按需获取注意： 禁止<code>HGETALL</code>全量查询；字段名建议简短化（如用<code>n</code>代替<code>name</code>）</td>
      </tr>
      <tr>
          <td style="text-align: left">List</td>
          <td style="text-align: left">消息队列、最新列表（如最近评论）</td>
          <td style="text-align: left">需随机访问、大量删除中间元素的场景</td>
          <td style="text-align: left">核心：<code>LPUSH</code>/<code>RPOP</code>注意：避免<code>LINDEX</code>（O(n)耗时）；长度控制在1000以内，过长需分片</td>
      </tr>
      <tr>
          <td style="text-align: left">Set</td>
          <td style="text-align: left">去重集合（如用户标签、共同好友）</td>
          <td style="text-align: left">需要元素有序、需按分数排序的场景</td>
          <td style="text-align: left">核心：<code>SINTER</code>/<code>SUNION</code>注意：集合操作仅限小集合（&lt;1000）；避免使用<code>SMEMBERS</code>全量返回</td>
      </tr>
      <tr>
          <td style="text-align: left">Sorted Set</td>
          <td style="text-align: left">排序场景（如排行榜、带权重的队列）</td>
          <td style="text-align: left">无需排序、高频更新分数的简单集合</td>
          <td style="text-align: left">核心：<code>ZRANGEBYSCORE</code>注意：用分页查询禁止全量返回；分数范围不宜过大以防内存占用高</td>
      </tr>
      <tr>
          <td style="text-align: left">Bitmap</td>
          <td style="text-align: left">二进制状态记录（如签到、在线状态）</td>
          <td style="text-align: left">非布尔型场景、ID极其不连续/稀疏的场景</td>
          <td style="text-align: left">核心：<code>BITCOUNT</code>/<code>BITOP</code>注意：避免单个Bitmap过大，建议按用户ID区间进行分片存储</td>
      </tr>
      <tr>
          <td style="text-align: left">HyperLogLog</td>
          <td style="text-align: left">基数统计（如UV计数、独立访客）</td>
          <td style="text-align: left">需要精确计数、需要存储/提取原始数据的场景</td>
          <td style="text-align: left">核心：<code>PFADD</code>/<code>PFCOUNT</code>注意：接受0.81%误差；不支持删除单个元素，适合固定生命周期场景</td>
      </tr>
  </tbody>
</table>
<p><strong>选型原则</strong>：</p>
<ul>
<li><strong>有限紧凑存储</strong>：如用户标签用Set而非多个String，对象属性用Hash而非JSON字符串</li>
<li><strong>避免低效操作</strong>：禁止key *（阻塞Redis），改用scan迭代；禁止List得lrem全量删除（O(n)耗时）</li>
<li><strong>大key拆分</strong>：单个key的value大小≤100KB，超过时拆分（如大Hash按ID区间拆分为多个小Hash）</li>
</ul>
<h3 id="过期策略">过期策略</h3>
<ol>
<li><strong>必须设置过期时间的场景（强制约束）</strong></li>
</ol>
<ul>
<li><strong>缓存数据</strong>：如商品详情、用户会话、接口返回结果（避免Redis成为“内存黑洞”）</li>
<li><strong>临时数据</strong>：如验证码（5分钟）、分布式锁（30秒+续期）、限流计数（1小时）</li>
<li><strong>周期性数据</strong>：如每日排行榜、当日活跃用户（过期时间设为次日凌晨）</li>
</ul>
<ol start="2">
<li>允许不设置过期时间的场景（严格限制）
仅以下场景可豁免，且需满足 “数据量极小（总占用内存≤1MB）、长期不变、核心配置”：</li>
</ol>
<ul>
<li>系统基础配置（如业务开关、常量字典，如<code>common:config:business_switch</code>）</li>
<li>永久标识映射（如用户ID与唯一编码的映射，且总量≤1万条）</li>
<li>豁免场景需经技术负责人审批，并在key中注明permanent标识（如<code>common:permanent:config:pay_channels</code>）</li>
</ul>
<ol start="3">
<li><strong>过期时间设置原则</strong></li>
</ol>
<ul>
<li><strong>与业务时效匹配</strong>：
<ul>
<li>高频变更数据（如库存）：5-10分钟（结合主动更新，避免缓存与数据库不一致）</li>
<li>低频变更数据（如地区字典）：1-7天（配合更新机制，如变更时主动删除缓存）</li>
<li>会话数据：与用户会话超时时间一致（如 2 小时）</li>
</ul>
</li>
<li><strong>避免集中过期</strong>：批量生成的key（如定时任务结果）需加随机偏移量（如 3600 + rand(0, 300) 秒），防止过期清理时的 CPU 峰值</li>
<li><strong>原子化设置</strong>：优先用<code>SET key value EX seconds</code>或<code>HSET key field value EX seconds</code>（Redis 6.2+支持Hash字段过期），避免SET后单独EXPIRE（中间故障可能导致key永久有效）</li>
</ul>
<ol start="4">
<li><strong>过期策略监控</strong></li>
</ol>
<ul>
<li>定期巡检：通过redis-cli &ndash;bigkeys或监控工具（如Prometheus+Redis Exporter）排查无过期时间的key，非豁免场合必须整改</li>
<li>告警阈限：五过期时间的key数量占比&gt;5%时触发告警，内存占比&gt;1%时紧急处理</li>
</ul>
<h3 id="核心注意事项">核心注意事项</h3>
<ol>
<li><strong>缓存一致性与更新</strong></li>
</ol>
<ul>
<li>优先采用 “更新数据库后删除缓存”（而非更新缓存），避免并发场景下的缓存脏数据</li>
<li>高并发更新场景需加锁（如分布式锁），防止缓存击穿（缓存失效时大量请求直达数据库）</li>
<li>缓存穿透防护：对不存在的key缓存空值（设置短期过期，如1分钟），避免恶意请求攻击数据库</li>
</ul>
<ol start="2">
<li><strong>内存与性能控制</strong></li>
</ol>
<ul>
<li>内存使用率阈值：生产环境 Redis 内存使用率≤80%（避免触发内存淘汰策略导致正常数据被删）</li>
<li>禁止存储大value：单个value＞1MB 需拆分（如大JSON拆分为多个小key），避免网络传输耗时过长</li>
<li>控制key总量：单实例key数量建议≤1000万（过多会导致Redis启动加载慢、内存碎片率高）</li>
</ul>
<ol start="3">
<li><strong>安全与合规</strong></li>
</ol>
<ul>
<li>禁止缓存敏感信息：如密码、身份证号、银行卡号（如需缓存，必须加密且过期时间≤1小时）</li>
<li>权限控制：开发/测试环境Redis禁止直连生产实例；生产环境仅允许应用服务通过指定账号访问，禁止人工redis-cli操作（特殊情况需审批）</li>
</ul>
<ol start="4">
<li><strong>环境隔离</strong></li>
</ol>
<ul>
<li>不同环境（开发/测试/生产）必须使用独立Redis实例或数据库（select dbindex），禁止共用实例（避免测试数据污染生产）</li>
<li>多团队共用Redis集群时，通过 “系统标识” 严格隔离，禁止跨团队操作非自有 key</li>
</ul>
<ol start="5">
<li><strong>命令使用禁忌</strong></li>
</ol>
<ul>
<li>禁止使用阻塞命令：keys *、flushall、flushdb（生产环境禁用，测试环境需谨慎）</li>
<li>限制高危命令：hgetall、smembers、zrange等全量查询命令仅允许在小集合上使用（元素≤100）</li>
<li>禁用eval复杂脚本：避免长时间阻塞Redis主线程（脚本执行时间≤100ms）</li>
</ul>

</article>

                
    
    
        
        <footer class="site-footer">
            <p>&copy; 2026 Feiesos&#39; blog</p>
        </footer>
    


            </div>
        </main>
    </body>
</html>
